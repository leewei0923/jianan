# 日志

## 规则

年份: 二级标题

月份: 三级级标题

当天: 四级标题

**后置任务不可增添标题**

标准格式

```
#### 09.28
> 周二
TaskList:
1.
2.

details
1.

Question:
1.
2.
```

```
#### 09.26
> 周日
TaskList:

Question:

> 周总结 09.20 - 09.26
  1. 
  2.
```



## 2021

### 08

#### 08.13

Task:
1. 字节面试笔记整理 √
2. 简历准备


Question



Review
1. 字节面试笔记整理
   - E:\前端学习\字节练习\面试准备\面试.md


Out


#### 08.14

Task:
1. 字节面试笔记整理
2. 准备简历
3. 英语单词30词

Question


Out




#### 08.15

Task:
1. 字节面试笔记整理
2. 英语单词30词
3. 面试准备:css，常见的js问题，vue简单的，青城小程序，小程序api

Question


Out


#### 08.16

Task 

1. 整理面试题，总结经验
2. 未来规划

Question


Out



#### 08.17

Task

1. react初步入门
2. 面试笔记填写
3. 复习html知识


Question


Out

#### 08.18

Task

1. 学习react
2. 学习webpack

Question


Out



#### 08.19

Task

1. 学习react
2. 刷题

Question


Out

#### 08.20

Task 

1. 刷题
2. 学习react

Question


Out
1. 30个单词，英语听力，跟读 （1h）

### 09

#### 09.02

Task

1. react学习
2. 力扣刷题


Out

1. react实现随机点名
2. react的生命周期


#### 09.04

Task
1. leetcode刷题
2. react小demo
3. js数据结构

#### 09.05



> 计划:

1. react生命周期
2. js算法题
3. react 小demo完成
4. C++学习

> 实际完成:
> 1.react生命周期
> 9:42 -  11:17

2. react 小demo
11:17 - 17:19

#### 09.07
> 计划

1. 两个小时react demo 练习
2. C++学习

> 实际:

1. react demo 练习 时长2h

   ```
   - 管理后台页面框架搭建(一)
   - 管理狗太页面框架搭建(二)
   - 列表页面搭建
   - 表单页面搭建(一)
   ```

   

**问题:**

- antd，icon处理问题 (√)
- 路由问题 ( )

 

#### 09.08

>计划

1. react生命周期
2. react-admin
3. C++学习
4. ES6学习



> 实际

1. react-admin

```
- 表单页面搭建二
- 登录页面UI
- 管理后台登录判断
```

**问题**

1. 显示create已经弃用

![wj2eMr.png](https://t1.picb.cc/uploads/2021/09/08/wj2eMr.png)



v4 的 Form 不再需要通过 `Form.create()` 创建上下文。Form 组件现在自带数据域，因而 `getFieldDecorator` 也不再需要，直接写入 Form.Item 即可：

```javascript
// antd v3
const Demo = ({ form: { getFieldDecorator } }) => (
  <Form>
    <Form.Item>
      {getFieldDecorator('username', {
        rules: [{ required: true }],
      })(<Input />)}
    </Form.Item>
  </Form>
);
const WrappedDemo = Form.create()(Demo);
```

改成：

```javascript
// antd v4
const Demo = () => (
  <Form>
    <Form.Item name="username" rules={[{ required: true }]}>
      <Input />
    </Form.Item>
  </Form>
);
```

由于移除了 `Form.create()`，原本的 `onFieldsChange` 等方法移入 Form 中，通过 `fields` 对 Form 进行控制。



2. 表单验证



```javascript
<Form.Item
              label="价格"
              name="price"
              rules={[{ required: true, message: "请输入商品价格" },{validator:priceValidate}]}
            >
              <Input placeholder="请输入商品价格"></Input>
            </Form.Item>

const priceValidate = (rule, value, callback) => {
      if (value > 100) {
        callback("价格不能大于100");
      } else {
        callback();
      }
    };
```



#### 09.08

> 计划

1. c++线性表学习
2. ES6语法学习



> 实际完成

1. c++ 

   8:42 -- 



#### 09.23

生日快乐

> complete

1. 数据结构——线性表

2. demo4

3. 算法题——[217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

4. [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

5. canvas

> detail

```
算法题
```

- 类似于暴力破解javascript

```javascript
var containsDuplicate = function(nums) {
  let result = nums.filter((item,index,array)=>{
    return array.indexOf(item) != index;
  }
  )
  if(result.length > 0){
    return true;
  }else{
    return false;
  }

};
```

利用js中filter函数

- 排序

```javascript
let result = nums.sort((a,b)=>{
    return a - b
  }
  );

  let out;
  for(let i =0; i < result.length-1;i++){
    if(result[i] === result[i+1]){
        return true;
    }
  }
  return false;
```

- 哈希表

```javascript
 const map = new Map();
    for (let i = 0; i < nums.length; i++) {
        map.set(nums[i], i);
    }
    if (map.size === nums.length) {
        return false;
    } else {
        return true;
    }
```

2.  题二

```
53. 最大子序和
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 

示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```



- 动态规划

```javascript
var maxSubArray = function (nums) {
    let preSum = 0, maxSum = nums[0];
    for (let x of nums) {
        preSum = Math.max(x, preSum + x)
        maxSum = Math.max(preSum, maxSum)
    }
    return maxSum
};
```



#### 09.24

> complete

1. 力扣——[两数之和](https://leetcode-cn.com/problems/two-sum/)





- 两数之和——哈希表

```javascript
var twoSum = function (nums, target) {
    const map = new Map();
    for(let i = 0; i < nums.length;i++){
       if(map.has(target - nums[i])){
           let res = map.get(target - nums[i]);
           return[res,i];
       }
        map.set(nums[i],i);
    }
};
```

```
- 创建Map
- 对target - nums[i]进行判断，不然会返回undefind
- 存在就直接返回，不存在进行添加
```

- 合并两个数组

```
给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
示例 1：

输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

```javascript
var merge = function(nums1, m, nums2, n) {
  let pre = 0, next = 0;
  let cur;
  let newArray = new Array(m + n).fill(0);
  while(pre < m || next < n){
    if(next === n){
      cur = nums1[pre]
      pre++
    }else if(pre == m){
      cur = nums2[next]
      next++
    }else if(nums1[pre] <= nums2[next]){
      cur = nums1[pre]
      pre++
    }else{
      cur = nums2[next]
      next++
    }

    newArray[pre + next - 1] = cur
  }
  for(let n in newArray){
    nums1[n] = newArray[n];
  }
  return nums1;
};
```

#### 09.26

1. 金融市场

   ```
    1. 票据市场 p29
    	- 银行承兑汇票市场的意义☆
    2. 中央银行票据市场
    3. 大额可转让存单市场
   ```

   

2. 管理会计

```
1. 变动成本法与完全成本法 ☆☆ p27
	- 变动成本法与完全成本法的区别 ☆
	
```



3. 财务管理

```
= 三 风险与报酬

1. 风险概念
2. 风险的种类
3. 风险报酬

单项资产的风险报酬 ☆
步骤: - 计算期望报酬率
	 - 计算标准离差
     - 计算标准离差率
     - 计算风险报酬率
     - 计算投资报酬率

```

4. 两个数组的交集

给定两个数组，编写一个函数来计算它们的交集。

 

**示例 1：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
```

```javascript
var intersect = function (nums1, nums2) {
    //   先对nums1 和 nums2 进行排序
    nums1.sort((a, b) => { return a - b });
    nums2.sort((a, b) => { return a - b });
    //两个指针
    let pre = 0, next = 0;
    //放置结果的盒子
    let resultList = [];
    //对nums1 和 nums2进行循环,只要大于各自数组的长度退出循环
    while (pre < nums1.length && next < nums2.length) {
        if (nums1[pre] < nums2[next]) {
            pre++;
        } else if (nums1[pre] === nums2[next]) {
            resultList.push(nums1[pre]);
            pre++;
            next++;
        } else {
            next++;
        }
    }
    return resultList;
};

// 两个指针进行查找,对两个数进行查找,小的数的下标进行++ , 等于的话push进入结果
```

#### 09.28

> 周二

TaskList:

1. 结束昨天的任务form-wave
2. [ 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

> detail

2. 买卖股票的最佳时机

```javascript
//动态规划
var maxProfit = function(prices) {
     let max_profit = 0;
     let min_price = Infinity; //先定义最小值为嘴杂的

     prices.map((item)=>{
      if(item < min_price){
        min_price = item;
      }else if(item - min_price > max_profit){
        max_profit = item - min_price;
      }
     })

     return max_profit;
};

maxProfit([7,6,4,3,1]); //5
/*
思路:
1. 先定义最大值为0,最小值假设是最大的
2. 再进行遍历,寻找最小值,如果小于最小值,最小值等于当前值
3. 否则就进行当前值与最小值进行相减,获取到最大值,进行更新最大值.
*/

```



Question:

1. 



#### 09.29

> 周三

TaskList:

1. 金融市场学
2. 管理会计
3. 财务管理
4. 杨辉三角形 ----力扣

> detail

3. 财务管理

   - 资本资产定价模型P45

   - 资本资产定价模型的一般形式及影响因素
     $$
     K_i = R_F + \beta_i(R_M - R_F)
     $$

4. 杨辉三角形

```javascript
var generate = function (numRows) {
    if (numRows === 0)
        return [];
    result = [[1]];
    for (let i = 0; i < numRows - 1; i++) {
        let temp = [];
        let newList = [...result[i]];
        newList.unshift(0);
        let newList2 = [...result[i]]
        newList2.push(0);
        for (let j = 0; j < newList.length; j++) {
            temp.push(newList[j] + newList2[j]);
        }
        result.push(temp);
    }
    return result;
};
```

```
  1    
 1 1
1 2 1

10 第二层
01
11

011 第三层
110 
121

0121 第四层
1210
1331
```

#### 09.30

> 周四

TaskList:

1. 云会计系统
2. 财务共享实验
3. 力扣 ---- 字符串中第一个不重复的值

detail:

3. 字符串第一个

```
字符串中的第一个唯一字符
给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
s = "leetcode"
返回 0

s = "loveleetcode"
返回 2
```

- 暴力破解(不推荐)

```javascript
var firstUniqChar = function (s) {
    if (typeof s !== 'string' || s.length < 1)
        return -1;

    let newList = s.split('');

    for (let i = 0; i < newList.length; i++) {
        let newList2 = s.split('');
        let idx = newList.indexOf(newList[i]);
        newList2.splice(idx, 1);
        if (!newList2.includes(newList[i])) {
            return i;
        }
    }
    return -1;
};
```

### 10

<div style="color:red;">国庆快乐！祝福伟大的祖国繁荣昌盛！</div>



#### 10.01

> 周五

TaskList:

1. 力扣 ---- 旅行终点站
2. Pow(x,n)



details:

1. 旅行重点站

   给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。

   题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。

    

   ```
   示例 1：
   
   输入：paths = [["London","New York"],["New York","Lima"],["Lima","Sao Paulo"]]
   输出："Sao Paulo" 
   解释：从 "London" 出发，最后抵达终点站 "Sao Paulo" 。本次旅行的路线是 "London" -> "New York" -> "Lima" -> "Sao Paulo" 。
   
   
   ```

   ```javascript
   //哈希表
   var destCity = function (paths) {
       const map = new Map();
   
       for (let i = 0; i < paths.length; i++) {
           map.set(paths[i][0], paths[i][1]);
       }
   
       for (let j = 0; j < paths.length; j++) {
           if (!map.has(paths[j][1])) {
               return paths[j][1]
           }
       }
   };
   ```

   2. #### [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

      难度中等746

      实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 x 的 n 次幂函数（即，xn）。

       

      **示例 1：**

      ```
      输入：x = 2.00000, n = 10
      输出：1024.00000
      ```

```javascript
//暴力解法 不推荐

var myPow = function(x, n) {
    if (n < 0) {
    x = 1 / x;
    n = -n;
  }
  let result = 1;
  for (let i = 0; i < n; i++) {
    result = result * x;
  }

  return result;
};
// 对于跑力扣一般都是会超时间的
```



```javascript
var myPow = function (x, n) {
    //用于对倒数的处理
    if (n < 0) {
        x = 1 / x;
        n = -n;
    }

    return quickMut(x, n);
};
function quickMut(x, n) {
    if (n === 0) {
        return 1;
    }
    // n / 2 记得要向下取整
    let y = quickMut(x, ~~(n / 2));
    return n % 2 === 0 ? y * y : y * y * x;
};
```

#### 10.02

> 周六

TaskList

1.力扣 -- [字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

details:

1. 字符串中的第一个唯一字符

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

 ```
 示例：
 
 s = "leetcode"
 返回 0
 
 s = "loveleetcode"
 返回 2
 ```

```javascript
// 哈希表

var firstUniqChar = function (s) {
    if (s.length == 0) {
        return -1;
    }
    const map = new Map();
    for (let i = 0; i < s.length; i++) {
        if (map.has(s[i])) {
            map.set(s[i], -1);
        } else {
            map.set(s[i], i);
        }
    }
    for (let v of map.values()) {
        if (v !== -1) {
            return v;
        }
    }
    return -1;
};
```

```
// 思路
关键词: 第一个 不重复 存在返回索引 不存在返回 -1
1. 利用哈希表(唯一的key值)
2. 访问字符串的索引值，将它们存入哈希表，出现重复就更新值为-1 否则创建新值
3. 由于返回第一个不重复索引值，再对哈希表的值进行遍历，返回遇到一个不为-1的值就返回

```





#### 10.03

> 周日

TaskList 

1. 力扣每日一题
2. 微信小程序 ---- 小助手(暂定名)

details

1. [166. 分数到小数](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/)

   难度中等301

   给定两个整数，分别表示分数的分子 `numerator` 和分母 `denominator`，以 **字符串形式返回小数** 。

   如果小数部分为循环小数，则将循环的部分括在括号内。

   如果存在多个答案，只需返回 **任意一个** 。

   对于所有给定的输入，**保证** 答案字符串的长度小于 `104` 。

    

   **示例 1：**

   ```
   输入：numerator = 1, denominator = 2
   输出："0.5"
   ```

```javascript
var fractionToDecimal = function (numerator, denominator) {
    let flag = 1;

  if((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0)){
    flag = -1;
  }
        
    numerator = Math.abs(numerator);
    denominator = Math.abs(denominator);

  let remainder = numerator % denominator; //余数
  let quotient = Math.floor(numerator / denominator); //商

  if(remainder == 0){
    return "" + quotient * flag;
  }
 
// 处理带小数的
  const res = [];
  const map = new Map();
  res.push(quotient.toString());
  res.push('.');

  for(let i = 0; i <10000; i++){
    numerator = remainder * 10;
    quotient = Math.floor(numerator / denominator);
    remainder = numerator % denominator;
    if(map.has(numerator)){
      res.splice(map.get(numerator),0,'(');
      res.push(")");
      break;
    }
    
    res.push(quotient.toString());
    map.set(numerator, i + 2);
    if(remainder == 0) 
      break;
  
  }
  if(flag == -1)
        return "-" + res.join("");
    return res.join("");   
};
```

解法:

1. 分为两步 一为处理整数部分 二为处理小数部分(出现循环小数等)
2. 先处理正负数问题(math.abs())

3. 再进行整数运算 求商和 取模长 求商的时候不要使用~~,可能会出现问题
4. 处理小数的时候就和纸上列竖式差不多的步骤



2. [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

   难度中等492

   给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

   例如：
   给定二叉树 `[3,9,20,null,null,15,7]`,

   ```
       3
      / \
     9  20
       /  \
      15   7
   ```

   返回其自底向上的层序遍历为：

   ```
   [
     [15,7],
     [9,20],
     [3]
   ]
   ```
   
   ```javascript
   var levelOrderBottom = function(root) {
       const res = [];
       function loop(node, h) {
           if (!node) return;
           if (!res[h]) res[h] = []
           res[h].push(node.val);
   
           loop(node.left,  h + 1);
           loop(node.right, h + 1);
       }
   
       loop(root, 0);
       return res.reverse();
   };
   ```
   
   
   
   #### 10.04
   
   > 周一
   
   taskList:
   
   1. 力扣 ---- 最长子串字符
   2. 微信小程序 ---- 谷歌插件联动
   3. gatsby学习
   
   
   
   detail
   
   1. [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
   
      难度中等6195
   
      给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。
      
      ```
      输入: s = "pwwkew"
      输出: 3
      解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
           请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
      ```
      
      ```javascript
      var lengthOfLongestSubstring = function(s) {
        const map = new Map();
        let start = 0, res = 0;
        for(let i = 0; i < s.length; i++){
          if(map.has(s[i])){
            start = Math.max(map.get(s[i]),start);
          }
          res = Math.max(res,i - start + 1);
          map.set(s[i],i+1);
        }
        return res;
      };
      ```
      
      > 思路
      
      ```
      1. 对于做重复的题首先想到的是哈希表
      2. 定义开始序号start 和 结果变量res
      3. 再对该字符串进行遍历, 在哈希表表中出现过, 对start进行更新(变为最大序号)
      4. res就用当前遍历下标 i - start + 1 (为什么 + 1 ? )
      
      ```
      
      

#### 10.05

> 周二

taskList :

1. 力扣 ---- 每日一题 
2. 力扣 ---- 字节校园每日一题
3. ajax
4. 谷歌插件开发 
5. 英语单词

detail

#### 10.06

> 周三

任务列表:

1. 力扣 --- 每日一题

2. 谷歌插件

3. ajax应用 ,promise

5. react 和 gatsby

未完成:

1. ajax应用 ,promise
2. react 和 gatsby

今日小记:

​	国庆这几天主要在谷歌插件上花费时间多了一点，后面还有我的个人博客项目，还在学习中。但是今天基本的功能完成，可以收藏单词了，但是路还长，我要弄多人的，可以有账号密码登录的。目前处在1.2.1版本中，计划在1.5.0.是一个beta版本，暂时使用。



#### 10.07

> 周四



> 任务列表:

1. 力扣 ---- 每日一题

2. 谷歌插件和微信小程序

3. react gatsby

4. promise

> 未完成

3. react gatsby
4. promise



今日小记:

还是在谷歌插件和微信小程序上花费太多的时间，一是业务选择和技术难题，找了很长时间的解决方法，基本实现可以以账号密码登录，但是还不是特别保险，一切都是明文的。

#### 10.08

>  任务列表

1. promise

2. gatsby react

3. 力扣每日一题

4. 管理成本 

   ​    \- 对变动成本法和完全成本法的评价 P34

> 未完成

无



#### 10.09

> 任务列表

1. 力扣每日一题
3. react 
4. 复习ajax,promise
5. 财务共享原理

> 未完成

1. 复习ajax,promise



#### 10.10

> 任务列表

1. 力扣 ---- 每日一题
2. 力扣 ---- 周赛
3. gatsby 小demo
4. ajax promise复习