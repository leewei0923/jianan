# 日志

## 规则

年份: 二级标题

月份: 三级级标题

当天: 四级标题

**后置任务不可增添标题**

标准格式

```
#### 09.28
> 周二
TaskList:
1.
2.

Question:
1.
2.
```

```
#### 09.26
> 周日
TaskList:

Question:

> 周总结 09.20 - 09.26
  1. 
  2.
```



## 2021

### 08

#### 08.13

Task:
1. 字节面试笔记整理 √
2. 简历准备


Question



Review
1. 字节面试笔记整理
   - E:\前端学习\字节练习\面试准备\面试.md


Out


#### 08.14

Task:
1. 字节面试笔记整理
2. 准备简历
3. 英语单词30词

Question


Out




#### 08.15

Task:
1. 字节面试笔记整理
2. 英语单词30词
3. 面试准备:css，常见的js问题，vue简单的，青城小程序，小程序api

Question


Out


#### 08.16

Task 

1. 整理面试题，总结经验
2. 未来规划

Question


Out



#### 08.17

Task

1. react初步入门
2. 面试笔记填写
3. 复习html知识


Question


Out

#### 08.18

Task

1. 学习react
2. 学习webpack

Question


Out



#### 08.19

Task

1. 学习react
2. 刷题

Question


Out

#### 08.20

Task 

1. 刷题
2. 学习react

Question


Out
1. 30个单词，英语听力，跟读 （1h）

### 09

#### 09.02

Task

1. react学习
2. 力扣刷题


Out

1. react实现随机点名
2. react的生命周期


#### 09.04

Task
1. leetcode刷题
2. react小demo
3. js数据结构

#### 09.05



> 计划:

1. react生命周期
2. js算法题
3. react 小demo完成
4. C++学习

> 实际完成:
> 1.react生命周期
> 9:42 -  11:17

2. react 小demo
11:17 - 17:19

#### 09.07
> 计划

1. 两个小时react demo 练习
2. C++学习

> 实际:

1. react demo 练习 时长2h

   ```
   - 管理后台页面框架搭建(一)
   - 管理狗太页面框架搭建(二)
   - 列表页面搭建
   - 表单页面搭建(一)
   ```

   

**问题:**

- antd，icon处理问题 (√)
- 路由问题 ( )

 

#### 09.08

>计划

1. react生命周期
2. react-admin
3. C++学习
4. ES6学习



> 实际

1. react-admin

```
- 表单页面搭建二
- 登录页面UI
- 管理后台登录判断
```

**问题**

1. 显示create已经弃用

![wj2eMr.png](https://t1.picb.cc/uploads/2021/09/08/wj2eMr.png)



v4 的 Form 不再需要通过 `Form.create()` 创建上下文。Form 组件现在自带数据域，因而 `getFieldDecorator` 也不再需要，直接写入 Form.Item 即可：

```javascript
// antd v3
const Demo = ({ form: { getFieldDecorator } }) => (
  <Form>
    <Form.Item>
      {getFieldDecorator('username', {
        rules: [{ required: true }],
      })(<Input />)}
    </Form.Item>
  </Form>
);
const WrappedDemo = Form.create()(Demo);
```

改成：

```javascript
// antd v4
const Demo = () => (
  <Form>
    <Form.Item name="username" rules={[{ required: true }]}>
      <Input />
    </Form.Item>
  </Form>
);
```

由于移除了 `Form.create()`，原本的 `onFieldsChange` 等方法移入 Form 中，通过 `fields` 对 Form 进行控制。



2. 表单验证



```javascript
<Form.Item
              label="价格"
              name="price"
              rules={[{ required: true, message: "请输入商品价格" },{validator:priceValidate}]}
            >
              <Input placeholder="请输入商品价格"></Input>
            </Form.Item>

const priceValidate = (rule, value, callback) => {
      if (value > 100) {
        callback("价格不能大于100");
      } else {
        callback();
      }
    };
```



#### 09.08

> 计划

1. c++线性表学习
2. ES6语法学习



> 实际完成

1. c++ 

   8:42 -- 



#### 09.23

生日快乐

> complete

1. 数据结构——线性表

2. demo4

3. 算法题——[217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

4. [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

5. canvas

> detail

```
算法题
```

- 类似于暴力破解javascript

```javascript
var containsDuplicate = function(nums) {
  let result = nums.filter((item,index,array)=>{
    return array.indexOf(item) != index;
  }
  )
  if(result.length > 0){
    return true;
  }else{
    return false;
  }

};
```

利用js中filter函数

- 排序

```javascript
let result = nums.sort((a,b)=>{
    return a - b
  }
  );

  let out;
  for(let i =0; i < result.length-1;i++){
    if(result[i] === result[i+1]){
        return true;
    }
  }
  return false;
```

- 哈希表

```javascript
 const map = new Map();
    for (let i = 0; i < nums.length; i++) {
        map.set(nums[i], i);
    }
    if (map.size === nums.length) {
        return false;
    } else {
        return true;
    }
```

2.  题二

```
53. 最大子序和
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 

示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```



- 动态规划

```javascript
var maxSubArray = function (nums) {
    let preSum = 0, maxSum = nums[0];
    for (let x of nums) {
        preSum = Math.max(x, preSum + x)
        maxSum = Math.max(preSum, maxSum)
    }
    return maxSum
};
```



#### 09.24

> complete

1. 力扣——[两数之和](https://leetcode-cn.com/problems/two-sum/)





- 两数之和——哈希表

```javascript
var twoSum = function (nums, target) {
    const map = new Map();
    for(let i = 0; i < nums.length;i++){
       if(map.has(target - nums[i])){
           let res = map.get(target - nums[i]);
           return[res,i];
       }
        map.set(nums[i],i);
    }
};
```

```
- 创建Map
- 对target - nums[i]进行判断，不然会返回undefind
- 存在就直接返回，不存在进行添加
```

- 合并两个数组

```
给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
示例 1：

输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

```javascript
var merge = function(nums1, m, nums2, n) {
  let pre = 0, next = 0;
  let cur;
  let newArray = new Array(m + n).fill(0);
  while(pre < m || next < n){
    if(next === n){
      cur = nums1[pre]
      pre++
    }else if(pre == m){
      cur = nums2[next]
      next++
    }else if(nums1[pre] <= nums2[next]){
      cur = nums1[pre]
      pre++
    }else{
      cur = nums2[next]
      next++
    }

    newArray[pre + next - 1] = cur
  }
  for(let n in newArray){
    nums1[n] = newArray[n];
  }
  return nums1;
};
```

#### 09.26

1. 金融市场

   ```
    1. 票据市场 p29
    	- 银行承兑汇票市场的意义☆
    2. 中央银行票据市场
    3. 大额可转让存单市场
   ```

   

2. 管理会计

```
1. 变动成本法与完全成本法 ☆☆ p27
	- 变动成本法与完全成本法的区别 ☆
	
```



3. 财务管理

```
= 三 风险与报酬

1. 风险概念
2. 风险的种类
3. 风险报酬

单项资产的风险报酬 ☆
步骤: - 计算期望报酬率
	 - 计算标准离差
     - 计算标准离差率
     - 计算风险报酬率
     - 计算投资报酬率

```

4. 两个数组的交集

给定两个数组，编写一个函数来计算它们的交集。

 

**示例 1：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
```

```javascript
var intersect = function (nums1, nums2) {
    //   先对nums1 和 nums2 进行排序
    nums1.sort((a, b) => { return a - b });
    nums2.sort((a, b) => { return a - b });
    //两个指针
    let pre = 0, next = 0;
    //放置结果的盒子
    let resultList = [];
    //对nums1 和 nums2进行循环,只要大于各自数组的长度退出循环
    while (pre < nums1.length && next < nums2.length) {
        if (nums1[pre] < nums2[next]) {
            pre++;
        } else if (nums1[pre] === nums2[next]) {
            resultList.push(nums1[pre]);
            pre++;
            next++;
        } else {
            next++;
        }
    }
    return resultList;
};

// 两个指针进行查找,对两个数进行查找,小的数的下标进行++ , 等于的话push进入结果
```

#### 09.28

> 周二

TaskList:

1. 

Question:

1. 

